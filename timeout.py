import sys
import time
import multiprocessing
import functools
import signal


_is_windows = sys.platform.startswith('win')

class TimeoutError(AssertionError):

    def __init__(self, value="Timed Out"):
        self.value = value

    def __str__(self):
        return repr(self.value)


def _raise_exception(exception, exception_message):
    """ This function checks if a exception message is given.
    If there is no exception message, the default behaviour is maintained.
    If there is an exception message, the message is passed to the exception with the 'value' keyword.
    """
    if exception_message is None:
        raise exception()
    else:
        raise exception(exception_message)


def timeout(seconds=None, use_signals= not _is_windows, timeout_exception=TimeoutError, exception_message=None):
    """Add a timeout parameter to a function and return it.
    :param seconds: optional time limit in seconds or fractions of a second. If None is passed, no timeout is applied.
        This adds some flexibility to the usage: you can disable timing out depending on the settings.
    :type seconds: float
    :param use_signals: flag indicating whether signals should be used for timing function out or the multiprocessing
        When using multiprocessing, timeout granularity is limited to 10ths of a second.
    :type use_signals: bool
    :raises: TimeoutError if time limit is reached
    It is illegal to pass anything other than a function as the first
    parameter. The function is wrapped and returned to the caller.
    """
    def decorate(function):

        if use_signals:
            def handler(signum, frame):
                _raise_exception(timeout_exception, exception_message)

            @functools.wraps(function)
            def new_function(*args, **kwargs):
                new_seconds = kwargs.pop('timeout', seconds)
                if new_seconds:
                    old = signal.signal(signal.SIGALRM, handler)
                    signal.setitimer(signal.ITIMER_REAL, new_seconds)

                if not seconds:
                    return function(*args, **kwargs)

                try:
                    return function(*args, **kwargs)
                finally:
                    if new_seconds:
                        signal.setitimer(signal.ITIMER_REAL, 0)
                        signal.signal(signal.SIGALRM, old)
            return new_function
        else:
            @functools.wraps(function)
            def new_function(*args, **kwargs):
                timeout_wrapper = _Timeout(function, timeout_exception, exception_message, seconds)
                return timeout_wrapper(*args, **kwargs)
            return new_function

    return decorate


def _target(queue, function, *args, **kwargs):
    """Run a function with arguments and return output via a queue.
    This is a helper function for the Process created in _Timeout. It runs
    the function with positional arguments and keyword arguments and then
    returns the function's output by way of a queue. If an exception gets
    raised, it is returned to _Timeout to be raised by the value property.
    """
    try:
        queue.put((True, function(*args, **kwargs)))
    except:
        queue.put((False, sys.exc_info()[1]))


class _Timeout:

    """Wrap a function and add a timeout (limit) attribute to it.
    Instances of this class are automatically generated by the add_timeout
    function defined above. Wrapping a function allows asynchronous calls
    to be made and termination of execution after a timeout has passed.
    """

    def __init__(self, function, timeout_exception, exception_message, limit):
        """Initialize instance in preparation for being called."""
        self.__limit = limit
        self.__function = function
        self.__timeout_exception = timeout_exception
        self.__exception_message = exception_message
        self.__name__ = function.__name__
        self.__doc__ = function.__doc__
        self.__timeout = time.time()
        self.__process = multiprocessing.Process()
        self.__queue = multiprocessing.Queue()

    def __call__(self, *args, **kwargs):
        """Execute the embedded function object asynchronously.
        The function given to the constructor is transparently called and
        requires that "ready" be intermittently polled. If and when it is
        True, the "value" property may then be checked for returned data.
        """
        self.__limit = kwargs.pop('timeout', self.__limit)
        self.__queue = multiprocessing.Queue(1)
        args = (self.__queue, self.__function) + args
        self.__process = multiprocessing.Process(target=_target,
                                                 args=args,
                                                 kwargs=kwargs)
        self.__process.daemon = True
        self.__process.start()
        if self.__limit is not None:
            self.__timeout = self.__limit + time.time()
        while not self.ready:
            time.sleep(0.01)
        return self.value

    def cancel(self):
        """Terminate any possible execution of the embedded function."""
        if self.__process.is_alive():
            self.__process.terminate()

        _raise_exception(self.__timeout_exception, self.__exception_message)

    @property
    def ready(self):
        """Read-only property indicating status of "value" property."""
        if self.__limit and self.__timeout < time.time():
            self.cancel()
        return self.__queue.full() and not self.__queue.empty()

    @property
    def value(self):
        """Read-only property containing data returned from function."""
        if self.ready:
            flag, load = self.__queue.get()
            if flag:
                return load
            raise load

wrong_code = """
@timeout(seconds=3)
def f():
    time.sleep(100000)
"""

correct_code = """
def f():
    pass
decorated = timeout(seconds=3)(f)
"""

import ast
tree = ast.parse(wrong_code)

decorator = None
func_name = None
class DecoratorExtractor(ast.NodeTransformer):

    def visit_FunctionDef(self, node):
        global decorator, func_name
        func_name = node.name
        print("Please use decorated_{func_name}")
        decorator = node.decorator_list.copy()[0]
        node.decorator_list.clear()
        return node

class ExprExtractor(ast.NodeTransformer):

    def visit_Expr(self, node):
        global expr
        expr = node.value
        return node

class ExprAugmenter(ast.NodeTransformer):

    def visit_Expr(self, node):
        global decorator, expr
        return ast.copy_location(ast.Expr(
             value=ast.Call(func=decorator, args=[expr], keywords=[]) ,args=[], keywords=[]
        ), node)

class GenericVistor(ast.NodeVisitor):
    def generic_visit(self, node):
        node.lineno = None
        node.col_offset = None
        return node

# tree = ExprExtractor().visit(tree)
tree = DecoratorExtractor().visit(tree)
# tree = ExprAugmenter().visit(tree)
tree.body.insert(1, ast.Assign(
            targets=[ast.Name(id=f'decorated_{func_name}', ctx=ast.Store())],
            value=ast.Call(
                func=ast.Call(
                    func=ast.Name( id='timeout', ctx=ast.Load()),
                    args=[],
                    keywords=[
                        ast.keyword(
                            arg='seconds',
                            value=ast.Constant(value=3, kind=None),
                        ),
                    ],
                ),
                args=[ast.Name(lineno=4, col_offset=31, end_lineno=4, end_col_offset=32, id='f', ctx=ast.Load())],
                keywords=[],
            ),
            type_comment=None,
        ))
# tree = GenericVistor().visit(tree)
ast.fix_missing_locations(tree)
co = compile(tree, "<ast>", "exec")
exec(co)
# decorated_f()
